<script>
    class ChatbotKnowledgeBase {
        #chatbotCategoryId;

        constructor(chatbotCategoryName = 'Chatbot') {
            this.#findChatbotCategoryId(chatbotCategoryName);
        }

        #findChatbotCategoryId(categoryName) {
            fetch("/categories.json").then(response => response.json()).then(result => {
                let category = result.category_list.categories.find(c => c.name === categoryName);
                if (category) {
                    this.#chatbotCategoryId = category.id;
                    console.log("Using chatbot category " + categoryName + " with ID " + this.#chatbotCategoryId);
                } else {
                    console.error("Failed to find a category named " + categoryName);
                }
            }).catch(error => console.error("Failed to look up categories: " + error));
        }

        async importTopic(topicId, options = {}) {
            if (!Number.isInteger(topicId)) {
                return Promise.reject("topicId must be an integer.");
            }
            if (!this.#isObject(options)) {
                return Promise.reject("options must be an object.");
            }

            let sourceTopic = await this.#getTopic(topicId);
            let kbPostContent = this.#buildKbPostContent(sourceTopic, options);

            if ('update' in options) {
                console.log(await this.#updateKbTopic(sourceTopic, kbPostContent, options['update']));
            } else {
                console.log(await this.#createKbTopic(sourceTopic, kbPostContent));
            }
        }

        async #getTopic(topicId) {
            let response = await fetch("/t/" + topicId + ".json?include_raw=true");
            return response.json();
        }

        async #createKbTopic(sourceTopic, kbPostContent) {
            let response = await fetch("/posts.json", {
                method: "POST",
                headers: this.#buildApiRequestHeaders(),
                body: JSON.stringify({
                    title: this.#buildKbTopicTitle(sourceTopic),
                    raw: kbPostContent,
                    category: this.#chatbotCategoryId,
                }),
            });
            if (response.ok) {
                const result = await response.json();
                return Promise.resolve("Imported topic " + sourceTopic.id + " as new KB topic " + result.topic_id);
            } else {
                return Promise.reject("Failed to import topic " + sourceTopic.id + ": " + response.status + " " + response.statusText);
            }
        }

        async #updateKbTopic(sourceTopic, kbPostContent, kbTopicId) {
            if (!Number.isInteger(kbTopicId)) {
                return Promise.reject("KB topic ID must be an integer.");
            }

            let kbTopic = await this.#getTopic(kbTopicId);
            if (kbTopic.posts_count !== 1) {
                return Promise.reject("KB topic " + kbTopicId + " has " + kbTopic.posts_count + " posts. Expected 1.");
            }

            let response = await fetch("/t/-/" + kbTopicId + ".json", {
                method: "PUT",
                headers: this.#buildApiRequestHeaders(),
                body: JSON.stringify({
                    title: this.#buildKbTopicTitle(sourceTopic),
                }),
            });
            if (!response.ok) {
                return Promise.reject("Failed to update KB topic " + kbTopicId + " title: " + response.status + " " + response.statusText);
            }

            response = await fetch("/posts/" + kbTopic.post_stream.posts[0].id + ".json", {
                method: "PUT",
                headers: this.#buildApiRequestHeaders(),
                body: JSON.stringify({
                    raw: kbPostContent,
                    edit_reason: "Updated with KB tools.",
                }),
            });
            if (response.ok) {
                return Promise.resolve("Imported topic " + sourceTopic.id + " by updating KB topic " + kbTopicId);
            } else {
                return Promise.reject("Failed to update KB topic " + kbTopicId + " post content: " + response.status + " " + response.statusText);
            }
        }

        #buildKbTopicTitle(sourceTopic) {
            return "KB: " + sourceTopic.title;
        }

        #buildKbPostContent(topic, options) {
            let header = "**Topic title is:** " + topic.title + "\n";
            if (topic.tags.length > 0) {
                header += "**Topic tags are:** " + topic.tags.join(", ") + "\n";
            }

            let posts = topic.post_stream.posts;
            if ('include' in options && Array.isArray(options['include'])) {
                posts = posts.filter(post => options['include'].includes(post.post_number));
            } else if ('exclude' in options && Array.isArray(options['exclude'])) {
                posts = posts.filter(post => !options['exclude'].includes(post.post_number));
            }
            posts = posts.map((post) => {
                return "**Link to post " + post.post_number + " below is:** " + this.#buildLinkToPost(post) + "\n" + post.raw;
            }, this);

            return header + "\n" + posts.join("\n\n");
        }

        #buildLinkToPost(post) {
            let linkUrl = window.location.origin + "/t/" + post.topic_slug + "/" + post.topic_id;
            if (post.post_number > 1) {
                linkUrl += "/" + post.post_number;
            }
            return linkUrl;
        }

        #buildApiRequestHeaders() {
            return {
                "Content-Type": "application/json",
                "X-Csrf-Token": document.head.querySelector("meta[name=csrf-token]")?.content
            };
        }

        #isObject(x) {
            return typeof x === 'object' && x !== null && !Array.isArray(x);
        }
    }
</script>